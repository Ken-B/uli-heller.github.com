<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Groovy | Was ich so treibe...]]></title>
  <link href="http://uli-heller.github.com/blog/categories/groovy/atom.xml" rel="self"/>
  <link href="http://uli-heller.github.com/"/>
  <updated>2013-08-07T10:00:49+02:00</updated>
  <id>http://uli-heller.github.com/</id>
  <author>
    <name><![CDATA[Uli Heller]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[WSGEN - Wie man's mit Interfaces macht]]></title>
    <link href="http://uli-heller.github.com/blog/2012/11/30/wsgen/"/>
    <updated>2012-11-30T08:00:00+01:00</updated>
    <id>http://uli-heller.github.com/blog/2012/11/30/wsgen</id>
    <content type="html"><![CDATA[<h1>Erzeugen einer WSDL-Datei für ein JAXWS-Webservice-Interface</h1>

<h2>Vorab &ndash; unser Webservice</h2>

<p>Ausgangspunkt ist dieses Interface für unseren Webservice:</p>

<p>{% include_code java/wsdl/SampleWebService.java %}</p>

<p>Zusätzlich gibt&rsquo;s auch schon eine Implementierung dafür, nämlich diese:</p>

<p>{% include_code java/wsdl/SampleWebServiceImpl.java %}</p>

<p>Da wir nur zwei Quelldateien haben, können wir die schnell manuell durchkompilieren:</p>

<p>{% codeblock Kompilieren der Quelldateien lang:sh %}
$ javac SampleWebServiceImpl.java  # &hellip; kompiliert beide Dateien
$ ls
SampleWebService.class      SampleWebServiceImpl.java
SampleWebServiceImpl.class  SampleWebService.java
{% endcodeblock %}</p>

<h2>WSGEN &ndash; das übliche Vorgehen</h2>

<p>Das übliche Vorgehen basiert auf dem Tool <code>wsgen</code>, welches dem JDK beiliegt:</p>

<p>{% codeblock Vorgehen mit WSGEN lang:sh %}
$ wsgen -cp . SampleWebServiceImpl -wsdl -inlineSchemas
$ ls
jaxws                   SampleWebServiceImpl.class  SampleWebService.java
SampleWebService.class  SampleWebServiceImpl.java   SampleWebService.wsdl
{% endcodeblock %}</p>

<p>Da haben wir sie, die WSDL-Datei mit dem Namen &ldquo;SampleWebService.wsdl&rdquo;.</p>

<h2>WSGEN &ndash; das Problem</h2>

<p>Manchmal steht nur das Interface für den Webservice zur Verfügung, also nur die Datei <a href="/downloads/code/java/wsdl/SampleWebService.java">SampleWebService.java</a>. Wenn wir versuchen, daraus eine WSDL-Datei zu erzeugen, erscheint so eine Fehlermeldung:</p>

<p>{% codeblock WSGEN und ServiceInterface lang:sh %}
$ wsgen -cp . SampleWebService -wsdl -inlineSchemas
The class &ldquo;SampleWebService&rdquo; is not an endpoint implementation class.</p>

<p>Usage: WSGEN [options] <SEI></p>

<p>where [options] include:
  -classpath <path>          specify where to find input class files
&hellip;
Examples:
  wsgen -cp . example.Stock
  wsgen -cp . example.Stock -wsdl -servicename {<a href="http://mynamespace">http://mynamespace</a>}MyService
{% endcodeblock %}</p>

<p>Wie&rsquo;s aussieht funktioniert WSGEN also nicht mit Interface-Klassen, es wird eine Implementierungsklasse benötigt:</p>

<ul>
<li><a href="http://java.net/jira/browse/JAX_WS-817">Jira-Ticket gegen JAXWS</a></li>
</ul>


<h2>Ein erster Versuch mit abstrakter Klasse</h2>

<p>Hier eine abstrakte Implementierungsklasse:</p>

<p>{% include_code java/wsdl/AbstractSampleWebServiceImpl.java %}</p>

<p>Leider klappt&rsquo;s auch nicht:</p>

<p>{% codeblock WSGEN mit abstrakter Implementierungsklasse lang:sh %}
$ javac AbstractSampleWebServiceImpl.java
$ wsgen -cp . AbstractSampleWebServiceImpl -wsdl -inlineSchemas
&hellip;
com.sun.tools.internal.ws.processor.modeler.ModelerException: modeler error: Classes annotated with @javax.jws.WebService must not be abstract. Class: AbstractSampleWebServiceImpl
&hellip;
{% endcodeblock %}</p>

<h2>Dynamische Erstellung einer Implementierungsklasse</h2>

<p>Der nächste Versuch sieht so aus:</p>

<ul>
<li>ich lade das Interface und untersuche alle seine Methoden</li>
<li>daraus erzeuge ich den Quelltext für eine Implementierungsklasse</li>
<li>die Implementierungsklasse kompiliere ich mit dem JavaCompiler</li>
<li>auf die dabei erstellte .class-Datei lasse ich dann <code>wsgen</code> los</li>
</ul>


<p>Den Versuch habe ich in einem <a href="http://github.com/uli-heller/uli-wsgen">GITHUB-Projekt</a> plattformübergreifend umgesetzt. Er scheint grundsätzlich zu funktionieren, ich kann in meinem aktuellen Projekt auf die manuelle Erstellung von Dummy-Implementierungsklassen verzichten.</p>

<p>Beispielaufruf: <code>./uli-wsgen.sh -c myproject.jar -f sample.wsdl SampleWebService</code></p>
]]></content>
  </entry>
  
</feed>
