<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Was ich so treibe...]]></title>
  <link href="http://uli-heller.github.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://uli-heller.github.com/"/>
  <updated>2013-08-07T10:00:49+02:00</updated>
  <id>http://uli-heller.github.com/</id>
  <author>
    <name><![CDATA[Uli Heller]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JBoss Application Server 7 unter Ubuntu nutzen]]></title>
    <link href="http://uli-heller.github.com/blog/2013/05/16/jboss-7.1.1/"/>
    <updated>2013-05-16T19:00:00+02:00</updated>
    <id>http://uli-heller.github.com/blog/2013/05/16/jboss-7.1.1</id>
    <content type="html"><![CDATA[<h2>Installation und Kurztest von JBoss AS</h2>

<ul>
<li>Paket von <a href="http://www.jboss.org/jbossas/downloads">http://www.jboss.org/jbossas/downloads</a> herunterladen,
einspielen und starten:</li>
</ul>


<p>{% codeblock Einspielen und Starten von JBossAS lang:sh %}</p>

<h1>jboss-as-7.1.1.Final.tar.gz heruntergeladen nach ~/Downloads</h1>

<p>cd /opt
gzip -cd ~/Downloads/jboss-as-7.1.1.Final.tar.gz |sudo tar xf &ndash;</p>

<h1>&hellip; es darf keine Fehlermeldung erscheinen!</h1>

<p>sudo chown -R uli.uli jboss-as-7.1.1.Final
cd  jboss-as-7.1.1.Final
./bin/standalone.sh</p>

<h1>&hellip; muß ohne Fehlermeldung starten</h1>

<p>{% endcodeblock %}</p>

<ul>
<li>Test mit <a href="https://localhost:8080">https://localhost:8080</a>: Es muß grob &ldquo;Welcome to AS 7&rdquo;
angezeigt werden.</li>
</ul>


<h2>Probleme</h2>

<ul>
<li>Keine, auch nicht mit JDK6</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JMX auf Localhost]]></title>
    <link href="http://uli-heller.github.com/blog/2013/03/22/localhost-jmx/"/>
    <updated>2013-03-22T08:00:00+01:00</updated>
    <id>http://uli-heller.github.com/blog/2013/03/22/localhost-jmx</id>
    <content type="html"><![CDATA[<h1>JMX so aktivieren, dass der Zugriff nur via Localhost möglich ist</h1>

<p>Im Java-Umfeld gibt es die JMX-Schnittstelle, die u.a. für&rsquo;s Monitoringittels JCONSOLE verwendet werden kann. Für meine eigenen Java-Prozesse ist das schnell erledigt: Einfach den Java-Prozess starten, dann <code>jconsole</code> (ohne Zusatzargument). Es wird eine Liste mit allen meinem Java-Prozessen angezeigt und ich kann einfach den gewünschten auswählen. Danach bekomme ich eine Anzeige ähnlich dieser:</p>

<p>{% img /images/java/jconsole.png %}</p>

<p>Dummerweise werden Webanwendungen manchmal mit anderen Benutzern gestartet, die noch dazu recht abgeschottet sind. Da scheitert der vorige Wert für mich &ndash; die betreffenden Tomcats erscheinen dann einfach nicht in der Liste. Das ist der Punkt, an dem man gerne die Remote-Schnittstelle über das setzen diverser Java-Properties freischaltet. Dumm dabei: Nun kann netzwerkweit auf die JMX-Schnittstelle zugegriffen werden &ndash; sofern man sie nicht zusätzlich abblockt, was auch wieder Aufwand bedeutet.</p>

<p>Ziel: Wir wollen die JMX-Schnittstelle so in Betrieb nehmen, dass nur von &ldquo;localhost&rdquo; aus auf sie zugegriffen werden kann!</p>

<!-- more -->


<h2>JMX für Netzwerkzugriffe öffnen</h2>

<p>Hier das klassische Vorgehen mittels Java-Properties:</p>

<p>{% codeblock tomcat/bin/setenv.sh %}
CATALINA_OPTS=&ldquo;-Djava.rmi.server.hostname=localhost&rdquo;
CATALINA_OPTS=&ldquo;-Dcom.sun.management.jmxremote ${CATALINA_OPTS}&rdquo;
CATALINA_OPTS=&ldquo;-Dcom.sun.management.jmxremote.port=11223 ${CATALINA_OPTS}&rdquo;
CATALINA_OPTS=&ldquo;-Dcom.sun.management.jmxremote.authenticate=false ${CATALINA_OPTS}&rdquo;
CATALINA_OPTS=&ldquo;-Dcom.sun.management.jmxremote.ssl=false ${CATALINA_OPTS}&rdquo;
{% endcodeblock %}</p>

<p>Nachteile:</p>

<ul>
<li><p>Das ist ein Scheunentor &ndash; netzwerkweit &ldquo;jeder&rdquo; kann nun mittels JMX auf unsere Anwendung zugreifen</p></li>
<li><p>Absichern könnte man&rsquo;s mit Firewall-Regeln, was aber zusätzliche Arbeitslast für die Firewall-Truppe bedeutet</p></li>
<li><p>Oder man aktiviert die Authentifizierung und hängt so eine Art Benutzerverwaltung mit dran &ndash; auch doof</p></li>
</ul>


<p>Eine Idee ist nun, den JMX-Port nicht netzwerkweit sondern nur über &ldquo;localhost&rdquo; erreichbar zu machen. Praktisch bedeutet dies, dass dann nur Leute, die sich auf dem betreffenden Rechner anmelden können, Zugriff auf die JMX-Schnittstelle haben. Die oben aufgeführten Java-Properties bieten leider keine entsprechende Einschränkmöglichkeit, also muß eine andere Lösung her!</p>

<h2>JMX über eine eigene RMISocketFactory freigeben</h2>

<p>Die Idee für nachfolgendes Vorgehen stammt von <a href="http://stackoverflow.com/questions/347056/restricting-jmx-to-localhost">StackOverflow</a>. Grob geht&rsquo;s so:</p>

<ul>
<li>Eigene RMISocketFactory erstellen und registrieren</li>
<li>MBeanServer über die Standard-ManagementFactory &ldquo;holen&rdquo;</li>
<li>MBeanServer mit der eigenen RMISocketFactory &ldquo;verknüpfen&rdquo; und einen JMXConnectorServer dafür erzeugen und starten</li>
</ul>


<p>Zusätzlich zu den in der Quelle auf <a href="http://stackoverflow.com/questions/347056/restricting-jmx-to-localhost">StackOverflow</a> umgesetzten Schritte mußte ich noch das Java-Property &ldquo;java.rmi.server.hostname&rdquo; auf &ldquo;127.0.0.1&rdquo; setzen. Ohne diesen Zusatzschritt funktioniert später JCONSOLE nicht.</p>

<p>Wenn man das richtig getan hat, dann kann man danach mittels <code>jconsole localhost:11223</code> die JCONSOLE starten. &ldquo;11223&rdquo; ist dabei die Portnummer, die man bei vorigem Ablauf mit verarbeitet.</p>

<p>Ich habe das ganze noch in ein Servlet verpackt. Nun kann ich durch</p>

<ul>
<li><code>curl http://localhost-jmx/jmx/start</code> &hellip; die JMX-Schnittstelle &ldquo;öffnen&rdquo;</li>
<li><code>curl http://localhost-jmx/jmx/stop</code> &hellip; die JMX-Schnittstelle &ldquo;schließen&rdquo;</li>
</ul>


<p>Zur Not geht das auch über einen Browser.</p>

<p>Seitens des Operatings sind keinerlei Eingriffe erforderlich. Auch das lästige Setzen des Java-Properties erübrigt sich.</p>

<p>Den Quelltext zu dem ganzen gibt&rsquo;s auf <a href="https://github.com/uli-heller/uli-java-prototypes/tree/master/localhost-jmx">GitHub</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCPMON]]></title>
    <link href="http://uli-heller.github.com/blog/2013/02/21/tcpmon/"/>
    <updated>2013-02-21T12:00:00+01:00</updated>
    <id>http://uli-heller.github.com/blog/2013/02/21/tcpmon</id>
    <content type="html"><![CDATA[<h1>Analyse von TCP-Datenströmen</h1>

<p>Früher gab&rsquo;s mal ein Programm von Apache, welches sich in TCP-Datenströme
einklinken ließ. Das Teil hieß TCPMON und war u.a. als Bestandteil von AXIS
verfügbar.</p>

<h2>TCPMON auf GoogleCode</h2>

<ul>
<li>Version 1.1 runtergeladen</li>
<li>Gestartet</li>
<li>Beobachtung: Funktioniert, aber Pakete werden nicht angezeigt. Damit
ist das Paket ziemlich sinnfrei</li>
</ul>


<h2>Notizen</h2>

<p>```sh
git svn clone -r 700000:HEAD <a href="http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/tcpmon">http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/tcpmon</a></p>

<h1>&hellip; das dauert</h1>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WSGEN - Wie man's mit Interfaces macht]]></title>
    <link href="http://uli-heller.github.com/blog/2012/11/30/wsgen/"/>
    <updated>2012-11-30T08:00:00+01:00</updated>
    <id>http://uli-heller.github.com/blog/2012/11/30/wsgen</id>
    <content type="html"><![CDATA[<h1>Erzeugen einer WSDL-Datei für ein JAXWS-Webservice-Interface</h1>

<h2>Vorab &ndash; unser Webservice</h2>

<p>Ausgangspunkt ist dieses Interface für unseren Webservice:</p>

<p>{% include_code java/wsdl/SampleWebService.java %}</p>

<p>Zusätzlich gibt&rsquo;s auch schon eine Implementierung dafür, nämlich diese:</p>

<p>{% include_code java/wsdl/SampleWebServiceImpl.java %}</p>

<p>Da wir nur zwei Quelldateien haben, können wir die schnell manuell durchkompilieren:</p>

<p>{% codeblock Kompilieren der Quelldateien lang:sh %}
$ javac SampleWebServiceImpl.java  # &hellip; kompiliert beide Dateien
$ ls
SampleWebService.class      SampleWebServiceImpl.java
SampleWebServiceImpl.class  SampleWebService.java
{% endcodeblock %}</p>

<h2>WSGEN &ndash; das übliche Vorgehen</h2>

<p>Das übliche Vorgehen basiert auf dem Tool <code>wsgen</code>, welches dem JDK beiliegt:</p>

<p>{% codeblock Vorgehen mit WSGEN lang:sh %}
$ wsgen -cp . SampleWebServiceImpl -wsdl -inlineSchemas
$ ls
jaxws                   SampleWebServiceImpl.class  SampleWebService.java
SampleWebService.class  SampleWebServiceImpl.java   SampleWebService.wsdl
{% endcodeblock %}</p>

<p>Da haben wir sie, die WSDL-Datei mit dem Namen &ldquo;SampleWebService.wsdl&rdquo;.</p>

<h2>WSGEN &ndash; das Problem</h2>

<p>Manchmal steht nur das Interface für den Webservice zur Verfügung, also nur die Datei <a href="/downloads/code/java/wsdl/SampleWebService.java">SampleWebService.java</a>. Wenn wir versuchen, daraus eine WSDL-Datei zu erzeugen, erscheint so eine Fehlermeldung:</p>

<p>{% codeblock WSGEN und ServiceInterface lang:sh %}
$ wsgen -cp . SampleWebService -wsdl -inlineSchemas
The class &ldquo;SampleWebService&rdquo; is not an endpoint implementation class.</p>

<p>Usage: WSGEN [options] <SEI></p>

<p>where [options] include:
  -classpath <path>          specify where to find input class files
&hellip;
Examples:
  wsgen -cp . example.Stock
  wsgen -cp . example.Stock -wsdl -servicename {<a href="http://mynamespace">http://mynamespace</a>}MyService
{% endcodeblock %}</p>

<p>Wie&rsquo;s aussieht funktioniert WSGEN also nicht mit Interface-Klassen, es wird eine Implementierungsklasse benötigt:</p>

<ul>
<li><a href="http://java.net/jira/browse/JAX_WS-817">Jira-Ticket gegen JAXWS</a></li>
</ul>


<h2>Ein erster Versuch mit abstrakter Klasse</h2>

<p>Hier eine abstrakte Implementierungsklasse:</p>

<p>{% include_code java/wsdl/AbstractSampleWebServiceImpl.java %}</p>

<p>Leider klappt&rsquo;s auch nicht:</p>

<p>{% codeblock WSGEN mit abstrakter Implementierungsklasse lang:sh %}
$ javac AbstractSampleWebServiceImpl.java
$ wsgen -cp . AbstractSampleWebServiceImpl -wsdl -inlineSchemas
&hellip;
com.sun.tools.internal.ws.processor.modeler.ModelerException: modeler error: Classes annotated with @javax.jws.WebService must not be abstract. Class: AbstractSampleWebServiceImpl
&hellip;
{% endcodeblock %}</p>

<h2>Dynamische Erstellung einer Implementierungsklasse</h2>

<p>Der nächste Versuch sieht so aus:</p>

<ul>
<li>ich lade das Interface und untersuche alle seine Methoden</li>
<li>daraus erzeuge ich den Quelltext für eine Implementierungsklasse</li>
<li>die Implementierungsklasse kompiliere ich mit dem JavaCompiler</li>
<li>auf die dabei erstellte .class-Datei lasse ich dann <code>wsgen</code> los</li>
</ul>


<p>Den Versuch habe ich in einem <a href="http://github.com/uli-heller/uli-wsgen">GITHUB-Projekt</a> plattformübergreifend umgesetzt. Er scheint grundsätzlich zu funktionieren, ich kann in meinem aktuellen Projekt auf die manuelle Erstellung von Dummy-Implementierungsklassen verzichten.</p>

<p>Beispielaufruf: <code>./uli-wsgen.sh -c myproject.jar -f sample.wsdl SampleWebService</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ASM - BytecodeOutline-Plugin in Eclipse installieren]]></title>
    <link href="http://uli-heller.github.com/blog/2012/11/27/bytecodeoutline/"/>
    <updated>2012-11-27T08:00:00+01:00</updated>
    <id>http://uli-heller.github.com/blog/2012/11/27/bytecodeoutline</id>
    <content type="html"><![CDATA[<h1>BytecodeOutline-Plugin für Eclipse</h1>

<p>Zuerst ein paar Angaben zu meiner Systemumgebung:</p>

<ul>
<li>Ubuntu-12.04, 64bit</li>
<li>Eclipse-jee-juno-SR1</li>
<li><a href="http://forge.ow2.org/projects/asm/">de.loskutov.BytecodeOutline_2.4.0.jar</a></li>
</ul>


<p>Ich benötige das Plugin nur temporär. Es soll nicht permanent in meiner Eclipse-Umgebung verfügbar sein.</p>

<h2>Neue Eclipse-Installation</h2>

<p>{% codeblock Neue Eclipse-Installation lang:sh %}
cd /opt
gzip -cd &ldquo;${HOME}/Downloads/eclipse/eclipse-jee-juno-SR1-linux-gtk-x86_64.tar.gz |sudo tar xf &ndash;
sudo chown -R uli.uli eclipse
sudo mv eclipse eclipse-botst
{% endcodeblock %}</p>

<h2>Test der neuen Eclipse-Installation</h2>

<p>{% codeblock Test der Eclipse-Installation lang:sh %}
/opt/eclipse-botst/eclipse &amp;</p>

<h1>Eclipse wird gestartet</h1>

<h1>&ndash;> wieder stoppen</h1>

<p>{% endcodeblock %}</p>

<h2>Einspielen des Plugins</h2>

<p>{% codeblock Einspielen des Plugins lang:sh %}</p>

<h1>Sicherstellen: Eclipse ist gestoppt</h1>

<p>cd /opt/eclipse-botst
cp &ldquo;${HOME}/Downloads/de.loskutov.BytecodeOutline_2.4.0.jar dropins
{% endcodeblock %}</p>

<h2>Kurztest des Plugins</h2>

<ul>
<li>Eclipse starten</li>
<li>Java-Klasse aus einem bestehenden Eclipse-Projekt selektieren</li>
<li>Window &ndash;> Show View &ndash;> Other &ndash;> Java &ndash;> Bytecode</li>
</ul>


<p>{% img /images/java/eclipse/bytecode-outline.png &lsquo;Eclipse mit Bytecode-View&rsquo; %}</p>
]]></content>
  </entry>
  
</feed>
